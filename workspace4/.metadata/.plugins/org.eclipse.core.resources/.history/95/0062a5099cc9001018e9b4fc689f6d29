/*
 * Copyright (c) 2009-2012 Xilinx, Inc.  All rights reserved.
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "xil_cache.h"
#include <mb_interface.h>

#include "xparameters.h"
#include <xil_types.h>
#include <xil_assert.h>

#include <xio.h>
#include "xtmrctr.h"
#include "fft.h"
#include "note.h"
#include "stream_grabber.h"
#include "xintc.h"
#include "trig.h"
#define RESET_VALUE 100000
#define SAMPLES 512 // AXI4 Streaming Data FIFO has size 512
#define M 9 //2^m=samples
#define CLOCK 100000000.0 //clock speed

#define LONG_BUF_SIZE 4096        // enough to store many blocks
static float mag_accum[SAMPLES];
static float mag_temp[SAMPLES];

static float long_buf[LONG_BUF_SIZE];
static int long_idx = 0;
static int initialized = 0;
int int_buffer[SAMPLES];
static float q[SAMPLES];
static float w[SAMPLES];
int count = 0;
int read_count = 0;
int fft_count = 0;
int find_count = 0;
int misc_count = 0;
int trig_count = 0;
int complex_count=0;
int computation_count = 0;
int interrupt_count = 0;
int print_count = 0;
unsigned seqf, seql, seq_old=0;
XIntc sys_intc;
XTmrCtr perfTimer;
//void print(char *str);
void Timer_ISR(void *CallbackRef)
{
	uint32_t ControlStatusReg;

	ControlStatusReg =
				XTimerCtr_ReadReg(perfTimer.BaseAddress, 0, XTC_TCSR_OFFSET);
    uint32_t ra;
    asm("add %0, r0, r14" : "=r"(ra));
    //xil_printf("ra: %d\r\n", ra);

    if (ra >= 0x80002fb8 && ra < 0x80003110){
        read_count++;
	}
    else if (ra >= 0x800022d0 && ra < 0x80002dc8){
    	fft_count++;
    }

    else if (ra >= 0x800034d0 && ra < 0x80003738 ){
        find_count++;
    }
    else if (ra>=0x80003114 && ra <0x800034d4){
       misc_count++;
    }
    else if(ra>=0x80000000 && ra < 0x800021d0){
    	computation_count++;
    }
    else if(ra>=0x800021d0 && ra < 0x800022cc){
    	complex_count++;
    }
    else if(ra>=0x80003f70 && ra < 0x8000405c){
        trig_count++;
    }

    else{
    	interrupt_count++;
    }


	count++;

    XTmrCtr_WriteReg(perfTimer.BaseAddress, 0,
                     XTC_TCSR_OFFSET, ControlStatusReg | XTC_CSR_INT_OCCURED_MASK);
}

void read_fsl_values(float* q, int n) {
    int i;

    stream_grabber_start();
    stream_grabber_wait_enough_samples(SAMPLES*4);

    seql = stream_grabber_read_seq_counter();
    seqf = stream_grabber_read_seq_counter_latched();

    int gap_blocks = 0;


    if (initialized) {
        int raw_gap = (int)(seqf - seq_old - 1);
        if (raw_gap < 0) raw_gap = 0;

        // raw_gap is in *raw* samples, but we skip by 4
        // so missing decimated units = raw_gap / 4
        gap_blocks = raw_gap / 4;
        if (gap_blocks > LONG_BUF_SIZE) gap_blocks = LONG_BUF_SIZE;
    } else {
        initialized = 1;
    }

    // Zero-pad the decimated gap
    for (i = 0; i < gap_blocks; i++) {
        long_buf[long_idx] = 0.0f;
        long_idx = (long_idx + 1) % LONG_BUF_SIZE;
    }

    // Read current block of 512 decimated samples
    for (i = 0; i < n; i++) {
        int32_t a = stream_grabber_read_sample(i*4 + 0);
        int32_t b = stream_grabber_read_sample(i*4 + 1);
        int32_t c = stream_grabber_read_sample(i*4 + 2);
        int32_t d = stream_grabber_read_sample(i*4 + 3);

        int_buffer[i] = (a + b + c + d)/4;   // divide by 4
    }

    // Append this block into the long timeline
    for (i = 0; i < n; i++) {
        long_buf[long_idx] = (3.3f * (float)int_buffer[i]) / 67108864.0f;
        //xil_printf("long_buf[%d] = %d\n\r", long_idx, (int)(long_buf[long_idx] * 1000000));
        long_idx = (long_idx + 1) % LONG_BUF_SIZE;

    }

    // Extract last 512 samples for FFT
    int start = (long_idx - n + LONG_BUF_SIZE) % LONG_BUF_SIZE;
    for (i = 0; i < n; i++) {
        q[i] = long_buf[(start + i) % LONG_BUF_SIZE];
        //xil_printf("q[%d] = %d\n\r", i, (int)(q[i] * 1000000));

    }

    seq_old = seql;
}


int main() {

   float sample_f;
   int l;
   int ticks; //used for timer
   uint32_t Control;
   float frequency;

   Xil_ICacheInvalidate();
   Xil_ICacheEnable();
   Xil_DCacheInvalidate();
   Xil_DCacheEnable();
   XIntc_Initialize(&sys_intc, XPAR_MICROBLAZE_0_AXI_INTC_DEVICE_ID);
      //set up timer

   XTmrCtr timer;
   XTmrCtr_Initialize(&timer, XPAR_AXI_TIMER_1_DEVICE_ID);
   Control = XTmrCtr_GetOptions(&timer,0) | XTC_CAPTURE_MODE_OPTION | XTC_INT_MODE_OPTION;
   XTmrCtr_SetOptions(&timer,0,Control);
   XTmrCtr_Start(&timer,0);

   //perf timer
   XIntc_Connect(&sys_intc,
                       XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_0_INTERRUPT_INTR,
                       (XInterruptHandler)Timer_ISR,
                       &perfTimer);
   XIntc_Enable(&sys_intc, XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_0_INTERRUPT_INTR);

   XTmrCtr_Initialize(&perfTimer, XPAR_AXI_TIMER_0_DEVICE_ID);

   XTmrCtr_SetOptions(&perfTimer, 0,
   				XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);


   XTmrCtr_SetResetValue(&perfTimer, 0,0xFFFFFFFF - RESET_VALUE);

   XIntc_Start(&sys_intc,XIN_REAL_MODE);
   XTmrCtr_Start(&perfTimer, 0);

   microblaze_register_handler((XInterruptHandler)XIntc_DeviceInterruptHandler,
		   (void*)XPAR_MICROBLAZE_0_AXI_INTC_DEVICE_ID);
   microblaze_enable_interrupts();

   init_fft_tables(SAMPLES);

   while (1) {
       // ---- N = number of FFT frames to average ----
       const int N = 4;   // try 4 first: 4 frames = 16k samples after decimation

       // clear accumulator
       for (int i = 0; i < SAMPLES; i++) mag_accum[i] = 0;

       for (int f = 0; f < N; f++) {
           read_fsl_values(q, SAMPLES);

           // call FFT normally but output complex into w[]
           fft(q, w, SAMPLES, M, sample_f/4);

           // compute magnitudes and accumulate
           for (int i = 0; i < SAMPLES; i++) {
               float re = w[2*i];
               float im = w[2*i + 1];
               mag_accum[i] += sqrtf(re*re + im*im);
           }
       }

       // average magnitudes
       for (int i = 0; i < SAMPLES; i++)
           mag_accum[i] /= N;

       // find dominant bin in averaged FFT
       int max_bin = 0;
       float max_val = mag_accum[0];
       for (int i = 1; i < SAMPLES/2; i++) {
           if (mag_accum[i] > max_val) {
               max_val = mag_accum[i];
               max_bin = i;
           }
       }

       // convert bin  frequency
       float frequency = max_bin * (sample_f/4) / SAMPLES;

       findNote(frequency);
   }


   return 0;
}
